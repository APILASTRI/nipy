#!/usr/bin/env python
# emacs: -*- mode: python; py-indent-offset: 4; indent-tabs-mode: nil -*-
# vi: set ft=python sts=4 ts=4 sw=4 et:

"""This is a wrapper of SpaceTimeRealign

Based on:

Alexis Roche (2011) A Four-Dimensional Registration Algorithm With Application to Joint Correction of Motion and Slice Timing in fMRI. IEEE Trans. Med. Imaging 30(8): 1546-1554

"""

import os
import numpy as np

import nibabel as nib
import matplotlib.mlab as mlab
import matplotlib.pyplot as plt

import nipy.algorithms.registration as reg
import nipy.externals.argparse as argparse
import nipy.algorithms.slicetiming as st
timefuncs = st.timefuncs.SLICETIME_FUNCTIONS

parser = argparse.ArgumentParser()

parser.add_argument('TR', type=float, metavar='Float', help="""The TR of the measurement""")

parser.add_argument('--input', type=str, metavar='File',
                help="""Path to a nifti file, or to a folder containing nifti files (Default: '.'). If a path to a folder is provided, the order of motion correction will be np.sort(list_of_files). The outputs will be '*_mc.par' (containing 3 translation and three rotation parameters) and '*_mc.nii.gz' containing the motion corrected data (unless 'apply' is set to False)""", default='.')

parser.add_argument('--slice_order', type=str, metavar='String',
                    help="""The order of slice aquisition {'ascending', 'descending' (default), or the name of a function from `nipy.algorithms.slicetiming.timefuncs`}""", default='descending')

parser.add_argument('--slice_dim', type=int, metavar='Int', help="""Integer
denoting the axis in `images` that is the slice axis.  In a 4D image, this will
often be axis = 2 (default).""", default=2)

parser.add_argument('--slice_dir', type=int, metavar='Int', help=""" 1 if the
slices were acquired slice 0 first (default), slice -1 last, or -1 if acquire slice -1 first, slice 0 last.""", default=1)

parser.add_argument('--apply', type=bool, metavar='Bool',
                help="""Whether to apply the realignment and save output files (default), or just estimate the realignment parameters and save those in '.par' files. {True, False}. Default: True""", default=True)

parser.add_argument('--make_figure', type=bool, metavar='Bool',
                help="""Whether to generate a '.png' figure with the motion parameters across runs. {True, False}. Default: False """, default=False)

# parse the command line
args = parser.parse_args()

if __name__ == '__main__':

    # If we got only a single file, we motion correct that one:
    if os.path.isfile(args.input):
        if not (args.input.endswith('.nii') or args.input.endswith('.nii.gz')):
            e_s = "Input needs to be a nifti file ('.nii' or '.nii.gz'"
            raise ValueError(e_s)
        input = nib.load(args.input)
        fnames = [args.input]
    else:
        list_of_files = os.listdir(args.input)
        fnames = [os.path.join(args.input, f) for f in np.sort(list_of_files)
                  if (f.endswith('.nii') or f.endswith('.nii.gz')) ]
        input = [nib.load(x) for x in fnames]

    slice_times = timefuncs[args.slice_order]
    slice_info = [int(args.slice_dim),
                  int(args.slice_dir)]

    reggy = reg.SpaceTimeRealign(input,
                                 float(args.TR),
                                 slice_times,
                                 slice_info)

    reggy.estimate(align_runs=True)
    # This will be the dtype for the recarray of params in all runs:
    dt = [('t1',float), ('t2', float), ('t3', float),
          ('r1',float), ('r2', float), ('r3', float)]

    # We now have the transformation parameters in here:
    transforms = reggy._within_run_transforms

    # We'll keep the last transformation in each run, so that we can
    # concatenate the transformations between runs:
    rot_last = [0, 0, 0]
    trans_last = [0, 0, 0]

    params_arr = []

    # There's a list for every run:
    for run_idx, this_trans in enumerate(transforms):
        this_rot = np.array([t.rotation for t in this_trans])
        this_trans = np.array([t.translation for t in this_trans])
        # To create a recarray, we need to first make a list of tuples:
        prep_arr = [(this_trans[i, 0] + trans_last[0],
                     this_trans[i, 1] + trans_last[1],
                     this_trans[i, 2] + trans_last[2],
                     this_rot[i, 0] + rot_last[0],
                     this_rot[i, 1] + rot_last[1],
                     this_rot[i, 2] + rot_last[2])
                     for i in range(this_rot.shape[0])]

        params_arr.append(np.array(prep_arr, dtype=dt))
        mlab.rec2csv(params_arr[-1], fnames[run_idx].split('.')[0] + '_mc.par')

        rot_last = [prep_arr[-1][0], prep_arr[-1][1], prep_arr[-1][2]]
        trans_last = [prep_arr[-1][3], prep_arr[-1][4], prep_arr[-1][5]]

    if args.apply:
        # dbg
        # print("Applying motion correction")
        new_reggy = reggy.resample(align_runs=True)
        # dbg
        for run_idx, new_im in enumerate(new_reggy):
            new_data = new_im.get_data()
            # We use the top 4 by 4 as the affine for the new file we will
            # create:
            new_aff = new_im.affine[:4, :4]
            new_ni = nib.Nifti1Image(new_data, new_aff)
            # Save it out to a '.nii.gz' file:
            new_ni.to_filename(fnames[run_idx].split('.')[0] + '_mc.nii.gz')

    if args.make_figure:
        all_params = np.concatenate(params_arr)
        figure, ax = plt.subplots(2)
        figure.set_size_inches([8, 6])
        ax[0].plot(all_params['t1'])
        ax[0].plot(all_params['t2'])
        ax[0].plot(all_params['t3'])
        ax[0].set_xlabel('Time (TR)')
        ax[0].set_ylabel('Translation (mm)')
        ax[1].plot(all_params['r1'])
        ax[1].plot(all_params['r2'])
        ax[1].plot(all_params['r3'])
        ax[1].set_xlabel('Time (TR)')
        ax[1].set_ylabel('Rotation (radians)')
        figure.savefig(os.path.join(os.path.split(fnames[0])[0],
                                    'mc_params.png'))

